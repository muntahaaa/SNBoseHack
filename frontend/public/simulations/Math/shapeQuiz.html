<!DOCTYPE html>
<html lang="en">
<head>    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Quadrilateral Explorer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f7ff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: #2c5aa0;
            color: white;
            border: none;
            border-radius: 25px;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background-color: #1c4277;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }

        .back-button:before {
            content: "←";
            margin-right: 8px;
            font-size: 18px;
        }

        h1 {
            color: #2c5aa0;
            margin-bottom: 10px;
            font-size: 1.8rem;
        }

        .quiz-container {
            display: none;
            width: 100%;
            max-width: 600px;
            background-color: #e0eafc;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .quiz-question {
            font-size: 1.2rem;
            font-weight: 600;
            color: #2c5aa0;
            margin-bottom: 15px;
            text-align: center;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .quiz-option {
            background-color: #ffffff;
            border: 2px solid #b2c9f0;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            text-align: center;
            transition: all 0.2s ease;
        }

        .quiz-option:hover {
            background-color: #e9f0ff;
            transform: translateY(-2px);
        }

        .quiz-option.selected {
            background-color: #c5d8ff;
            border-color: #6a93d4;
        }

        .quiz-option.correct {
            background-color: #d4edda;
            border-color: #5cb85c;
        }

        .quiz-option.incorrect {
            background-color: #f8d7da;
            border-color: #dc3545;
        }

        .scoreboard {
            display: none;
            background-color: #ffffff;
            padding: 8px 20px;
            border-radius: 25px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-weight: 600;
            color: #2c5aa0;
        }

        .explanation {
            display: none;
            background-color: #ffffff;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border-left: 4px solid #6a93d4;
        }

        .main-container {
            display: flex;
            width: 100%;
            max-width: 1000px;
            gap: 20px;
            margin: 0 auto;
            flex-wrap: wrap;
        }

        .shape-info {
            background-color: #ffffff;
            padding: 8px 20px;
            border-radius: 25px;
            margin-bottom: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-weight: 600;
            color: #2c5aa0;
        }

        .canvas-container {
            position: relative;
            flex: 1;
            min-width: 300px;
        }

        canvas {
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            touch-action: none;
            width: 100%;
            max-width: 600px;
            height: auto;
            aspect-ratio: 1 / 1;
        }

        .controls {
            display: flex;
            flex-direction: column;
            width: 200px;
            background-color: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            align-self: flex-start;
        }

        h2 {
            color: #2c5aa0;
            font-size: 1.2rem;
            margin-top: 0;
            margin-bottom: 15px;
        }

        .checkbox-group {
            margin-bottom: 15px;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            accent-color: #2c5aa0;
        }

        .checkbox-container label {
            color: #444;
            font-size: 0.95rem;
        }

        button {
            background-color: #2c5aa0;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 25px;
            font-size: 1rem;
            cursor: pointer;
            margin-top: 5px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }

        button:hover {
            background-color: #1c3f75;
            transform: translateY(-2px);
        }

        .quiz-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .quiz-btn {
            background-color: #6a93d4;
            font-size: 0.95rem;
            padding: 8px 15px;
        }

        .quiz-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #learnButton {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
        }

        #learnButton:hover {
            background-color: #45a049;
        }

        #popup {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        #popup button {
            background-color: #f44336;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            display: block;
            margin-left: auto;
        }

        #popup button:hover {
            background-color: #d32f2f;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
                align-items: center;
            }
            
            .controls {
                width: 100%;
                max-width: 300px;
            }

            canvas {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <button id="learnButton" style="position: fixed; bottom: 40px; right: 60px; z-index: 1000;">এসো জ্যামিতিক আকার শিখি</button>
    <button class="back-button" onclick="window.close()">Back to Math Page</button>
    <h1>Interactive Quadrilateral Explorer</h1>
    
    <div class="scoreboard" id="scoreboard" role="status">
        Score: <span id="score">0</span>
    </div>

    <div class="shape-info" id="shape-info" role="status">
        Shape: <span id="shape-type">Detecting...</span>
    </div>

    <div class="quiz-container" id="quiz-container">
        <div class="quiz-question" id="quiz-question">
            What type of quadrilateral is shown?
        </div>
        <div class="quiz-options" id="quiz-options" role="radiogroup">
            <!-- Quiz options will be populated here -->
        </div>
        <div class="explanation" id="explanation">
            <!-- Explanation will be populated here -->
        </div>
        <div class="quiz-controls">
            <button class="quiz-btn" id="check-answer" disabled aria-label="Check selected answer">Check Answer</button>
            <button class="quiz-btn" id="next-question" style="display: none;" aria-label="Proceed to next question">Next Shape</button>
        </div>
    </div>

    <div class="main-container">
        <div class="canvas-container">
            <canvas id="quadCanvas" aria-label="Interactive quadrilateral canvas"></canvas>
        </div>
        
        <div class="controls">
            <h2>Display Options</h2>
            <div class="checkbox-group">
                <div class="checkbox-container">
                    <input type="checkbox" id="show-grid" checked aria-label="Toggle grid display">
                    <label for="show-grid">Show Grid</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-diagonals" aria-label="Toggle diagonals display">
                    <label for="show-diagonals">Show Diagonals</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-labels" checked aria-label="Toggle vertex labels display">
                    <label for="show-labels">Show Vertex Labels</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="snap-to-grid" aria-label="Toggle snap to grid">
                    <label for="snap-to-grid">Snap to Grid</label>
                </div>
            </div>
            
            <button id="reset-btn" aria-label="Reset points to initial positions">Reset Points</button>
            <button id="quiz-toggle-btn" aria-label="Toggle quiz mode">Quiz Mode: Off</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('quadCanvas');
        const ctx = canvas.getContext('2d');
        const shapeTypeDisplay = document.getElementById('shape-type');
        const shapeInfo = document.getElementById('shape-info');
        
        // Quiz elements
        const quizContainer = document.getElementById('quiz-container');
        const quizQuestion = document.getElementById('quiz-question');
        const quizOptions = document.getElementById('quiz-options');
        const explanation = document.getElementById('explanation');
        const checkAnswerBtn = document.getElementById('check-answer');
        const nextQuestionBtn = document.getElementById('next-question');
        const scoreboard = document.getElementById('scoreboard');
        const scoreDisplay = document.getElementById('score');
        
        // Control elements
        const showGridCheckbox = document.getElementById('show-grid');
        const showDiagonalsCheckbox = document.getElementById('show-diagonals');
        const showLabelsCheckbox = document.getElementById('show-labels');
        const snapToGridCheckbox = document.getElementById('snap-to-grid');
        const resetBtn = document.getElementById('reset-btn');
        const quizToggleBtn = document.getElementById('quiz-toggle-btn');
        
        // Responsive canvas size
        function resizeCanvas() {
            const maxWidth = window.innerWidth > 768 ? 600 : Math.min(window.innerWidth - 40, 400);
            canvas.width = maxWidth;
            canvas.height = maxWidth;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        const gridSize = canvasWidth / 15; // Adjusted grid size
        const pointRadius = canvasWidth / 60; // Adjusted point radius
        const minPointDistance = pointRadius * 2; // Minimum distance between points
        
        // Points A, B, C, D (initial positions)
        let points = [
            { x: canvasWidth * 0.25, y: canvasWidth * 0.25, label: 'A' },
            { x: canvasWidth * 0.75, y: canvasWidth * 0.25, label: 'B' },
            { x: canvasWidth * 0.75, y: canvasWidth * 0.75, label: 'C' },
            { x: canvasWidth * 0.25, y: canvasWidth * 0.75, label: 'D' }
        ];
        
        // Quiz state
        let isQuizMode = false;
        let score = 0;
        let selectedOptionIndex = null;
        let correctAnswer = null;
        let optionElements = [];
        
        // Dragging state
        let isDragging = false;
        let draggedPointIndex = -1;
        
        // Quadrilateral types and their explanations
        const quadTypes = [
            { name: 'Square', description: 'All sides are equal in length and all angles are 90 degrees.' },
            { name: 'Rectangle', description: 'All angles are 90 degrees, and opposite sides are equal in length.' },
            { name: 'Rhombus', description: 'All sides are equal in length, but angles are not necessarily 90 degrees.' },
            { name: 'Parallelogram', description: 'Opposite sides are parallel and equal in length.' },
            { name: 'Trapezoid', description: 'Exactly one pair of opposite sides are parallel.' },
            { name: 'Kite', description: 'Two pairs of adjacent sides are equal in length.' },
            { name: 'Irregular', description: 'Doesn\'t fit any of the special quadrilateral types.' }
        ];

        // Function to update all displays and calculations
        function updateDisplay() {
            clearCanvas();
            drawGrid();
            drawQuadrilateral();
            if (showDiagonalsCheckbox.checked) {
                drawDiagonals();
            }
            if (showLabelsCheckbox.checked) {
                drawVertexLabels();
            }
            detectShapeType();
        }
        
        // Clear the canvas
        function clearCanvas() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        }
        
        // Draw the grid
        function drawGrid() {
            if (!showGridCheckbox.checked) return;
            
            ctx.strokeStyle = "#e6e6e6";
            ctx.lineWidth = 1;
            
            for (let x = 0; x <= canvasWidth; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvasHeight);
                ctx.stroke();
            }
            
            for (let y = 0; y <= canvasHeight; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvasWidth, y);
                ctx.stroke();
            }
        }
        
        // Draw the quadrilateral
        function drawQuadrilateral() {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.strokeStyle = "#2c5aa0";
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.fillStyle = "rgba(106, 147, 212, 0.2)";
            ctx.fill();
            
            points.forEach((point, index) => {
                ctx.beginPath();
                ctx.arc(point.x, point.y, pointRadius, 0, 2 * Math.PI);
                ctx.fillStyle = "#2c5aa0";
                ctx.fill();
                ctx.strokeStyle = "#ffffff";
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        // Draw diagonals
        function drawDiagonals() {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[2].x, points[2].y);
            ctx.moveTo(points[1].x, points[1].y);
            ctx.lineTo(points[3].x, points[3].y);
            ctx.strokeStyle = "#ff9500";
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Draw vertex labels
        function drawVertexLabels() {
            ctx.font = `${canvasWidth / 37.5}px Arial`; // Responsive font size
            ctx.fillStyle = "#333";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            points.forEach(point => {
                ctx.fillText(point.label, point.x, point.y - pointRadius * 2);
            });
        }
        
        // Calculate distance between two points
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        
        // Check minimum distance between points
        function isTooClose(x, y, index) {
            for (let i = 0; i < points.length; i++) {
                if (i !== index && distance({ x, y }, points[i]) < minPointDistance) {
                    return true;
                }
            }
            return false;
        }
        
        // Calculate angle between three points (in degrees)
        function angle(p1, p2, p3) {
            const a = distance(p2, p3);
            const b = distance(p1, p3);
            const c = distance(p1, p2);
            if (a === 0 || c === 0) return 0; // Avoid division by zero
            const angleRadians = Math.acos((a * a + c * c - b * b) / (2 * a * c));
            return angleRadians * (180 / Math.PI);
        }
        
        // Check if two lines are parallel
        function areParallel(p1, p2, p3, p4) {
            const dx1 = p2.x - p1.x;
            const dy1 = p2.y - p1.y;
            const dx2 = p4.x - p3.x;
            const dy2 = p4.y - p3.y;
            
            if (Math.abs(dx1) < 0.01 && Math.abs(dx2) < 0.01) return true; // Both vertical
            if (Math.abs(dx1) < 0.01 || Math.abs(dx2) < 0.01) return false; // One vertical
            const slope1 = dy1 / dx1;
            const slope2 = dy2 / dx2;
            return Math.abs(slope1 - slope2) < 0.1 * (Math.abs(slope1) + Math.abs(slope2)) / 2;
        }
        
        // Check if all sides are equal
        function allSidesEqual() {
            const sides = [
                distance(points[0], points[1]),
                distance(points[1], points[2]),
                distance(points[2], points[3]),
                distance(points[3], points[0])
            ];
            const avg = sides.reduce((a, b) => a + b, 0) / 4;
            return sides.every(side => Math.abs(side - avg) / avg < 0.05);
        }
        
        // Check if all angles are 90 degrees
        function allAngles90() {
            const angles = [
                angle(points[3], points[0], points[1]),
                angle(points[0], points[1], points[2]),
                angle(points[1], points[2], points[3]),
                angle(points[2], points[3], points[0])
            ];
            return angles.every(a => !isNaN(a) && Math.abs(a - 90) < 5);
        }
        
        // Check if opposite sides are parallel
        function oppositeSidesParallel() {
            return areParallel(points[0], points[1], points[2], points[3]) &&
                   areParallel(points[1], points[2], points[3], points[0]);
        }
        
        // Check if exactly one pair of opposite sides are parallel
        function exactlyOnePairParallel() {
            const parallel1 = areParallel(points[0], points[1], points[2], points[3]);
            const parallel2 = areParallel(points[1], points[2], points[3], points[0]);
            return (parallel1 && !parallel2) || (!parallel1 && parallel2);
        }
        
        // Check if adjacent sides are equal (kite property)
        function hasAdjacentEqualSides() {
            const side1 = distance(points[0], points[1]);
            const side2 = distance(points[1], points[2]);
            const side3 = distance(points[2], points[3]);
            const side4 = distance(points[3], points[0]);
            
            const pattern1 = Math.abs(side1 - side2) / ((side1 + side2) / 2) < 0.05 &&
                            Math.abs(side3 - side4) / ((side3 + side4) / 2) < 0.05;
            const pattern2 = Math.abs(side2 - side3) / ((side2 + side3) / 2) < 0.05 &&
                            Math.abs(side4 - side1) / ((side4 + side1) / 2) < 0.05;
            return pattern1 || pattern2;
        }
        
        // Check if opposite sides are equal in length
        function oppositeSidesEqual() {
            const side1 = distance(points[0], points[1]);
            const side3 = distance(points[2], points[3]);
            const side2 = distance(points[1], points[2]);
            const side4 = distance(points[3], points[0]);
            return Math.abs(side1 - side3) / ((side1 + side3) / 2) < 0.05 &&
                   Math.abs(side2 - side4) / ((side2 + side4) / 2) < 0.05;
        }
        
        // Detect the type of quadrilateral
        function detectShapeType() {
            let shapeType = "Irregular";
            
            if (allSidesEqual() && allAngles90()) {
                shapeType = "Square";
            } else if (allAngles90() && oppositeSidesEqual()) {
                shapeType = "Rectangle";
            } else if (allSidesEqual() && oppositeSidesParallel()) {
                shapeType = "Rhombus";
            } else if (oppositeSidesParallel() && oppositeSidesEqual()) {
                shapeType = "Parallelogram";
            } else if (exactlyOnePairParallel()) {
                shapeType = "Trapezoid";
            } else if (hasAdjacentEqualSides()) {
                shapeType = "Kite";
            }
            
            shapeTypeDisplay.textContent = shapeType;
            return shapeType;
        }
        
        // Event listener for mouse down
        canvas.addEventListener('mousedown', (e) => {
            if (isQuizMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            for (let i = 0; i < points.length; i++) {
                if (distance({ x, y }, points[i]) < pointRadius * 1.5) {
                    isDragging = true;
                    draggedPointIndex = i;
                    break;
                }
            }
        });
        
        // Event listener for mouse move
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging || isQuizMode) return;
            
            const rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            
            if (snapToGridCheckbox.checked) {
                x = Math.round(x / gridSize) * gridSize;
                y = Math.round(y / gridSize) * gridSize;
            }
            
            x = Math.max(0, Math.min(x, canvasWidth));
            y = Math.max(0, Math.min(y, canvasHeight));
            
            if (!isTooClose(x, y, draggedPointIndex)) {
                points[draggedPointIndex].x = x;
                points[draggedPointIndex].y = y;
                updateDisplay();
            }
        });
        
        // Event listener for mouse up
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            draggedPointIndex = -1;
        });
        
        // Event listener for mouse leave
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            draggedPointIndex = -1;
        });
        
        // Event listeners for touch devices
        canvas.addEventListener('touchstart', (e) => {
            if (isQuizMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.touches[0].clientX - rect.left;
            const y = e.touches[0].clientY - rect.top;
            
            for (let i = 0; i < points.length; i++) {
                if (distance({ x, y }, points[i]) < pointRadius * 2) {
                    isDragging = true;
                    draggedPointIndex = i;
                    e.preventDefault();
                    break;
                }
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            if (!isDragging || isQuizMode) return;
            
            const rect = canvas.getBoundingClientRect();
            let x = e.touches[0].clientX - rect.left;
            let y = e.touches[0].clientY - rect.top;
            
            if (snapToGridCheckbox.checked) {
                x = Math.round(x / gridSize) * gridSize;
                y = Math.round(y / gridSize) * gridSize;
            }
            
            x = Math.max(0, Math.min(x, canvasWidth));
            y = Math.max(0, Math.min(y, canvasHeight));
            
            if (!isTooClose(x, y, draggedPointIndex)) {
                points[draggedPointIndex].x = x;
                points[draggedPointIndex].y = y;
                updateDisplay();
            }
            e.preventDefault();
        });
        
        canvas.addEventListener('touchend', () => {
            isDragging = false;
            draggedPointIndex = -1;
        });
        
        // Keyboard navigation for quiz options
        quizOptions.addEventListener('keydown', (e) => {
            if (!isQuizMode || e.key !== 'Enter') return;
            const focused = document.activeElement;
            if (focused.classList.contains('quiz-option')) {
                focused.click();
            }
        });
        
        // Event listeners for checkboxes
        showGridCheckbox.addEventListener('change', updateDisplay);
        showDiagonalsCheckbox.addEventListener('change', updateDisplay);
        showLabelsCheckbox.addEventListener('change', updateDisplay);
        
        // Reset button event listener
        resetBtn.addEventListener('click', () => {
            points = [
                { x: canvasWidth * 0.25, y: canvasWidth * 0.25, label: 'A' },
                { x: canvasWidth * 0.75, y: canvasWidth * 0.25, label: 'B' },
                { x: canvasWidth * 0.75, y: canvasWidth * 0.75, label: 'C' },
                { x: canvasWidth * 0.25, y: canvasWidth * 0.75, label: 'D' }
            ];
            updateDisplay();
        });
        
        // Quiz mode toggle
        quizToggleBtn.addEventListener('click', () => {
            isQuizMode = !isQuizMode;
            quizToggleBtn.textContent = `Quiz Mode: ${isQuizMode ? 'On' : 'Off'}`;
            
            if (isQuizMode) {
                quizContainer.style.display = 'block';
                scoreboard.style.display = 'block';
                shapeInfo.style.display = 'none';
                generateQuizQuestion();
            } else {
                quizContainer.style.display = 'none';
                scoreboard.style.display = 'none';
                shapeInfo.style.display = 'block';
                resetBtn.click();
            }
        });
        
        // Randomly position points to create a specific shape
        function generateRandomShape(shapeType) {
            const baseX = gridSize * 5;
            const baseY = gridSize * 5;
            const baseSize = gridSize * 5;
            
            switch(shapeType) {
                case 'Square':
                    points = [
                        { x: baseX, y: baseY, label: 'A' },
                        { x: baseX + baseSize, y: baseY, label: 'B' },
                        { x: baseX + baseSize, y: baseY + baseSize, label: 'C' },
                        { x: baseX, y: baseY + baseSize, label: 'D' }
                    ];
                    break;
                    
                case 'Rectangle':
                    points = [
                        { x: baseX, y: baseY, label: 'A' },
                        { x: baseX + baseSize * 1.5, y: baseY, label: 'B' },
                        { x: baseX + baseSize * 1.5, y: baseY + baseSize, label: 'C' },
                        { x: baseX, y: baseY + baseSize, label: 'D' }
                    ];
                    break;
                    
                case 'Rhombus':
                    points = [
                        { x: baseX + baseSize/2, y: baseY, label: 'A' },
                        { x: baseX + baseSize, y: baseY + baseSize/2, label: 'B' },
                        { x: baseX + baseSize/2, y: baseY + baseSize, label: 'C' },
                        { x: baseX, y: baseY + baseSize/2, label: 'D' }
                    ];
                    break;
                    
                case 'Parallelogram':
                    points = [
                        { x: baseX + baseSize/3, y: baseY, label: 'A' },
                        { x: baseX + baseSize * 1.2, y: baseY, label: 'B' },
                        { x: baseX + baseSize, y: baseY + baseSize, label: 'C' },
                        { x: baseX, y: baseY + baseSize, label: 'D' }
                    ];
                    break;
                    
                case 'Trapezoid':
                    points = [
                        { x: baseX + baseSize/4, y: baseY, label: 'A' },
                        { x: baseX + baseSize * 1.1, y: baseY, label: 'B' },
                        { x: baseX + baseSize, y: baseY + baseSize, label: 'C' },
                        { x: baseX, y: baseY + baseSize, label: 'D' }
                    ];
                    break;
                    
                case 'Kite':
                    points = [
                        { x: baseX + baseSize/2, y: baseY, label: 'A' },
                        { x: baseX + baseSize, y: baseY + baseSize/2, label: 'B' },
                        { x: baseX + baseSize/2, y: baseY + baseSize, label: 'C' },
                        { x: baseX + baseSize/4, y: baseY + baseSize/2, label: 'D' }
                    ];
                    break;
                    
                case 'Irregular':
                default:
                    points = [
                        { x: baseX + baseSize * 0.3, y: baseY + baseSize * 0.2, label: 'A' },
                        { x: baseX + baseSize * 0.9, y: baseY + baseSize * 0.1, label: 'B' },
                        { x: baseX + baseSize * 0.8, y: baseY + baseSize * 0.7, label: 'C' },
                        { x: baseX + baseSize * 0.2, y: baseY + baseSize * 0.6, label: 'D' }
                    ];
                    break;
            }
            
            if (shapeType !== 'Square' && shapeType !== 'Rectangle') {
                points.forEach(point => {
                    const offsetX = (Math.random() - 0.5) * gridSize * 0.2;
                    const offsetY = (Math.random() - 0.5) * gridSize * 0.2;
                    const newX = Math.max(0, Math.min(point.x + offsetX, canvasWidth));
                    const newY = Math.max(0, Math.min(point.y + offsetY, canvasHeight));
                    if (!isTooClose(newX, newY, points.indexOf(point))) {
                        point.x = newX;
                        point.y = newY;
                    }
                });
            }
            
            // Verify the shape matches the intended type
            let attempts = 0;
            while (detectShapeType() !== shapeType && attempts < 10) {
                points.forEach(point => {
                    const offsetX = (Math.random() - 0.5) * gridSize * 0.2;
                    const offsetY = (Math.random() - 0.5) * gridSize * 0.2;
                    const newX = Math.max(0, Math.min(point.x + offsetX, canvasWidth));
                    const newY = Math.max(0, Math.min(point.y + offsetY, canvasHeight));
                    if (!isTooClose(newX, newY, points.indexOf(point))) {
                        point.x = newX;
                        point.y = newY;
                    }
                });
                attempts++;
            }
            
            updateDisplay();
            return shapeType;
        }
        
        // Generate quiz question with multiple choice options
        function generateQuizQuestion() {
            explanation.style.display = 'none';
            checkAnswerBtn.disabled = true;
            checkAnswerBtn.style.display = 'block';
            nextQuestionBtn.style.display = 'none';
            selectedOptionIndex = null;
            quizOptions.innerHTML = '';
            optionElements = [];
            
            const shapeTypes = quadTypes.map(type => type.name).filter(type => type !== 'Irregular');
            const randomShapeIndex = Math.floor(Math.random() * shapeTypes.length);
            const targetShape = shapeTypes[randomShapeIndex];
            
            correctAnswer = generateRandomShape(targetShape);
            
            const options = [...quadTypes.map(type => type.name)];
            for (let i = options.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [options[i], options[j]] = [options[j], options[i]];
            }
            
            options.forEach((option, index) => {
                const optionElement = document.createElement('div');
                optionElement.className = 'quiz-option';
                optionElement.textContent = option;
                optionElement.dataset.index = index;
                optionElement.dataset.value = option;
                optionElement.tabIndex = 0;
                optionElement.setAttribute('role', 'radio');
                optionElement.setAttribute('aria-checked', 'false');
                
                optionElement.addEventListener('click', () => {
                    optionElements.forEach(el => {
                        el.classList.remove('selected');
                        el.setAttribute('aria-checked', 'false');
                    });
                    optionElement.classList.add('selected');
                    optionElement.setAttribute('aria-checked', 'true');
                    selectedOptionIndex = index;
                    checkAnswerBtn.disabled = false;
                });
                
                quizOptions.appendChild(optionElement);
                optionElements.push(optionElement);
            });
            
            // Focus the first option for accessibility
            optionElements[0].focus();
        }
        
        // Check answer event listener
        checkAnswerBtn.addEventListener('click', () => {
            if (selectedOptionIndex === null) return;
            
            const selectedOption = optionElements[selectedOptionIndex];
            const selectedValue = selectedOption.dataset.value;
            const shapeExplanation = quadTypes.find(type => type.name === correctAnswer).description;
            
            optionElements.forEach(option => {
                option.classList.remove('correct', 'incorrect');
                if (option.dataset.value === correctAnswer) {
                    option.classList.add('correct');
                }
            });
            
            if (selectedValue === correctAnswer) {
                selectedOption.classList.add('correct');
                score += 10;
                scoreDisplay.textContent = score;
                explanation.innerHTML = `<strong>Correct!</strong> This is a ${correctAnswer}. ${shapeExplanation}`;
            } else {
                selectedOption.classList.add('incorrect');
                explanation.innerHTML = `<strong>Not quite.</strong> This is a ${correctAnswer}. ${shapeExplanation}`;
            }
            
            explanation.style.display = 'block';
            checkAnswerBtn.style.display = 'none';
            nextQuestionBtn.style.display = 'block';
            optionElements.forEach(option => {
                option.style.pointerEvents = 'none';
                option.setAttribute('aria-disabled', 'true');
            });
            nextQuestionBtn.focus();
        });
        
        // Next question event listener
        nextQuestionBtn.addEventListener('click', generateQuizQuestion);
        
        // Initialize the display
        updateDisplay();
        function showPopup() {
        document.getElementById('popup').style.display = 'block';
        }

        
function closePopup() {
    document.getElementById('popup').style.display = 'none';
    // Stop audio if playing
    if (window.ttsAudio) {
        window.ttsAudio.pause();
        window.ttsAudio = null;
    }
}

        document.getElementById('learnButton').addEventListener('click', showPopup);
    
// Add TTS button event listener when document is ready
document.addEventListener('DOMContentLoaded', function() {
    const ttsButton = document.getElementById('ttsButton');
    if (ttsButton) {
        ttsButton.addEventListener('click', speakText);
    }
});
    
// TTS functionality
async function speakText() {
    const ttsButton = document.getElementById('ttsButton');
    const ttsStatus = document.getElementById('tts-status');
    const textToSpeak = document.getElementById('popup-content').textContent;
    
    // If audio is already playing, stop it
    if (window.ttsAudio && !window.ttsAudio.paused) {
        ttsStatus.textContent = 'বন্ধ করা হচ্ছে...';
        window.ttsAudio.pause();
        window.ttsAudio = null;
        ttsButton.style.backgroundColor = '#4CAF50';
        ttsButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
            শুনুন
        `;
        ttsStatus.textContent = '';
        return;
    }
    
    try {
        ttsButton.style.backgroundColor = '#ff9800';
        ttsButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
            </svg>
            <span class="loading-dots">লোড হচ্ছে</span>
        `;
        ttsStatus.textContent = '';
        
        // Call the backend TTS API
        const response = await fetch('http://localhost:5000/api/tts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                text: textToSpeak,
                language: 'bn-IN',  // Bengali language code
                voice: 'bn-IN-TanishaaNeural'  // Bengali voice
            })
        });
        
        if (!response.ok) {
            throw new Error(`TTS request failed: ${response.status} ${response.statusText}`);
        }
        
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        ttsStatus.textContent = '';
        
        // Create and play audio
        const audio = new Audio(audioUrl);
        window.ttsAudio = audio;
        
        audio.addEventListener('ended', () => {
            ttsButton.style.backgroundColor = '#4CAF50';
            ttsButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                    <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                    <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                </svg>
                শুনুন
            `;
            ttsStatus.textContent = '';
            window.ttsAudio = null;
            
            // Clean up
            URL.revokeObjectURL(audioUrl);
        });
        
        audio.addEventListener('error', (e) => {
            console.error('Audio playback error:', e);
            ttsButton.style.backgroundColor = '#f44336';
            ttsButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                    <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                </svg>
                ত্রুটি হয়েছে
            `;
            
            // Clean up
            URL.revokeObjectURL(audioUrl);
            
            setTimeout(() => {
                ttsButton.style.backgroundColor = '#4CAF50';
                ttsButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                        <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                    </svg>
                    শুনুন
                `;
                ttsStatus.textContent = '';
            }, 3000);
        });
        
        ttsButton.style.backgroundColor = '#ff5722';
        ttsButton.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
            থামান
        `;
        await audio.play();
    } catch (error) {
        console.error('TTS API error:', error);
        
        // Try using browser's built-in speech synthesis as fallback
        if (window.speechSynthesis) {
            try {
                ttsStatus.textContent = '';
                ttsButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                        <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                        <circle cx="18" cy="12" r="4" fill="currentColor"></circle>
                    </svg>
                    ব্রাউজারে চলছে
                `;
                
                // Find Bengali voice if available
                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                utterance.lang = 'bn-IN';
                
                // Try to find a Bengali voice
                const voices = speechSynthesis.getVoices();
                const bengaliVoice = voices.find(voice => 
                    voice.lang.includes('bn') || 
                    voice.name.toLowerCase().includes('bengali')
                );
                
                if (bengaliVoice) {
                    utterance.voice = bengaliVoice;
                }
                
                utterance.onend = () => {
                    ttsButton.style.backgroundColor = '#4CAF50';
                    ttsButton.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                            <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                        </svg>
                        শুনুন
                    `;
                    ttsStatus.textContent = '';
                };
                
                utterance.onerror = () => {
                    ttsButton.style.backgroundColor = '#f44336';
                    ttsButton.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                            <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                        </svg>
                        ত্রুটি হয়েছে
                    `;
                    setTimeout(() => {
                        ttsButton.style.backgroundColor = '#4CAF50';
                        ttsButton.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                                <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                            </svg>
                            শুনুন
                        `;
                        ttsStatus.textContent = '';
                    }, 3000);
                };
                
                ttsButton.style.backgroundColor = '#ff5722';
                speechSynthesis.speak(utterance);
            } catch (synthError) {
                console.error('Speech synthesis error:', synthError);
                ttsButton.style.backgroundColor = '#f44336';
                ttsButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                        <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                        <line x1="22" y1="2" x2="11" y2="13"></line>
                    </svg>
                    সমর্থিত নয়
                `;
                setTimeout(() => {
                    ttsButton.style.backgroundColor = '#4CAF50';
                    ttsButton.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                            <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                        </svg>
                        শুনুন
                    `;
                    ttsStatus.textContent = '';
                }, 3000);
            }
        } else {
            ttsButton.style.backgroundColor = '#f44336';
            ttsButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                    <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                    <line x1="22" y1="2" x2="11" y2="13"></line>
                </svg>
                সমর্থিত নয়
            `;
            setTimeout(() => {
                ttsButton.style.backgroundColor = '#4CAF50';
                ttsButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
                        <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                    </svg>
                    শুনুন
                `;
                ttsStatus.textContent = '';
            }, 3000);
        }
    }
}
</script>

<style>
    @keyframes loading-dots {
        0%, 20% { content: ""; }
        40% { content: "."; }
        60% { content: ".."; }
        80%, 100% { content: "..."; }
    }
    
    .loading-dots::after {
        content: "";
        animation: loading-dots 1.5s infinite;
        display: inline-block;
    }
    
    #ttsButton {
        transition: background-color 0.3s, transform 0.2s;
        font-weight: 500;
        display: flex;
        align-items: center;
    }
    
    #ttsButton:hover {
        background-color: #3e8e41 !important;
        transform: translateY(-1px);
    }
    
    #ttsButton:active {
        transform: scale(0.98);
    }
    
    #tts-status {
        transition: opacity 0.3s;
    }
</style>
    <div id="popup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border: 1px solid black; z-index: 1001; max-width: 500px; text-align: justify;">
    <p id="popup-content">জ্যামিতিক আকার আমাদের চারপাশে ছড়িয়ে আছে—তুমি যেদিকেই তাকাও, কোনো না কোনো আকার চোখে পড়বেই! জ্যামিতিক আকার মানে হলো এমন কিছু নির্দিষ্ট রূপ বা গঠন, যেগুলো রেখা, কোণ এবং পৃষ্ঠ দিয়ে তৈরি হয়। যেমন: বৃত্ত গোলাকার একটি আকার যার কোনো কোণ নেই, ত্রিভুজে তিনটি বাহু ও তিনটি কোণ থাকে, চতুর্ভুজে চারটি বাহু ও কোণ থাকে, আবার বর্গ ও আয়তক্ষেত্র হলো বিশেষ ধরনের চতুর্ভুজ। এ ছাড়া বহুভুজ মানে অনেক কোণ ও বাহু বিশিষ্ট আকার। এই আকারগুলো গণিতে ব্যবহার হয় দৈর্ঘ্য, ক্ষেত্রফল ও পরিসীমা নির্ণয় করার জন্য। জ্যামিতিক আকার শিখলে আমরা নকশা আঁকা, ভবন তৈরি, এমনকি শিল্পকর্মেও জ্ঞানের ব্যবহার করতে পারি!</p>
    
<div style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px;">
    <button id="ttsButton" style="display: flex; align-items: center; background-color: #4CAF50; color: white; border: none; border-radius: 5px; padding: 8px 12px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" title="শুনুন" aria-label="Read aloud">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px;">
            <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
            <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
        </svg>
        শুনুন
    </button>
    <div id="tts-status" style="color: #666; font-size: 14px; min-height: 20px; flex-grow: 1; text-align: center;"></div>
    <button onclick="closePopup()" style="background-color: #f44336; color: white; padding: 8px 16px; border: none; border-radius: 5px; cursor: pointer;">বন্ধ করুন</button>
</div>
</body>
</html>